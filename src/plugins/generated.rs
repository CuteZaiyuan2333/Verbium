// Generated by build.rs. DO NOT EDIT.

#[cfg(feature = "plugin_code_editor")]
pub mod code_editor;

#[cfg(feature = "plugin_file_manager")]
pub mod file_manager;

#[cfg(feature = "plugin_terminal")]
pub mod terminal;

#[cfg(feature = "plugin_test_plugin")]
pub mod test_plugin;


// Plugin Name Constants
#[cfg(feature = "plugin_code_editor")]
pub const PLUGIN_NAME_CODE_EDITOR: &str = "code_editor";
#[cfg(feature = "plugin_file_manager")]
pub const PLUGIN_NAME_FILE_MANAGER: &str = "file_manager";
#[cfg(feature = "plugin_terminal")]
pub const PLUGIN_NAME_TERMINAL: &str = "terminal";
#[cfg(feature = "plugin_test_plugin")]
pub const PLUGIN_NAME_TEST_PLUGIN: &str = "test_plugin";

pub fn get_extra_plugins() -> Vec<Box<dyn crate::Plugin>> {
    let mut plugins: Vec<Box<dyn crate::Plugin>> = Vec::new();
        #[cfg(feature = "plugin_code_editor")]
        {
            let p = Box::new(code_editor::create());
            assert_eq!(p.name(), PLUGIN_NAME_CODE_EDITOR, "Plugin name mismatch for code_editor");
            plugins.push(p);
        }
        #[cfg(feature = "plugin_file_manager")]
        {
            let p = Box::new(file_manager::create());
            assert_eq!(p.name(), PLUGIN_NAME_FILE_MANAGER, "Plugin name mismatch for file_manager");
            plugins.push(p);
        }
        #[cfg(feature = "plugin_terminal")]
        {
            let p = Box::new(terminal::create());
            assert_eq!(p.name(), PLUGIN_NAME_TERMINAL, "Plugin name mismatch for terminal");
            plugins.push(p);
        }
        #[cfg(feature = "plugin_test_plugin")]
        {
            let p = Box::new(test_plugin::create());
            assert_eq!(p.name(), PLUGIN_NAME_TEST_PLUGIN, "Plugin name mismatch for test_plugin");
            plugins.push(p);
        }
    plugins
}
