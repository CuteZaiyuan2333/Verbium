use std::path::{Path, PathBuf};
use std::collections::HashSet;
use std::sync::{Arc, Mutex};
use egui::{Ui, WidgetText, Id, Color32, RichText};
use crate::{Plugin, AppCommand, TabInstance, Tab, NotificationLevel};

// ----------------------------------------------------------------------------
// Tab Instance
// ----------------------------------------------------------------------------

#[derive(Clone)]
pub struct FileExplorerTab {
    root_path: Option<PathBuf>,
    expanded_nodes: HashSet<PathBuf>,
    rename_path: Option<PathBuf>,
    new_item_parent: Option<(PathBuf, bool)>, // (parent_path, is_dir)
    input_text: String,
    
    // New state for interaction
    selected_items: HashSet<PathBuf>,
    /// Queue for commands generated by background threads (e.g., move finished)
    pending_commands: Arc<Mutex<Vec<AppCommand>>>,
}

impl std::fmt::Debug for FileExplorerTab {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("FileExplorerTab")
            .field("root_path", &self.root_path)
            .finish()
    }
}

impl FileExplorerTab {
    fn new() -> Self {
        Self {
            root_path: None,
            expanded_nodes: HashSet::new(),
            rename_path: None,
            new_item_parent: None,
            input_text: String::new(),
            selected_items: HashSet::new(),
            pending_commands: Arc::new(Mutex::new(Vec::new())),
        }
    }

    /// Helper to process commands from background threads
    fn process_pending_commands(&self, control: &mut Vec<AppCommand>) {
        if let Ok(mut pending) = self.pending_commands.lock() {
            if !pending.is_empty() {
                control.append(&mut pending);
            }
        }
    }

    fn render_tree(&mut self, ui: &mut Ui, path: PathBuf, control: &mut Vec<AppCommand>) {
        let name = path.file_name()
            .map(|n| n.to_string_lossy().to_string())
            .unwrap_or_else(|| "/".to_string());

        let is_selected = self.selected_items.contains(&path);
        let id = Id::new(&path);
        let item_is_dir = path.is_dir();

        if item_is_dir {
            let is_expanded = self.expanded_nodes.contains(&path);
            
            let state = egui::collapsing_header::CollapsingState::load_with_default_open(
                ui.ctx(), 
                id, 
                is_expanded
            );

            let header_response = state.show_header(ui, |ui| {
                // Text styling
                let mut text = RichText::new(format!("üìÅ {}", name));
                if is_selected {
                    text = text.color(ui.visuals().selection.stroke.color);
                }

                // Render the label (Interactive for selection and DnD)
                let response = ui.add(egui::SelectableLabel::new(is_selected, text)).interact(egui::Sense::drag());
                
                // D&D: Drag Source
                if response.dragged() {
                    response.dnd_set_drag_payload(path.clone());
                    
                    ui.ctx().set_cursor_icon(egui::CursorIcon::Grabbing);
                    if let Some(pointer_pos) = ui.ctx().pointer_interact_pos() {
                        let count = if is_selected && self.selected_items.len() > 1 {
                            self.selected_items.len()
                        } else {
                            1
                        };
                        egui::Area::new(id.with("dnd_tooltip"))
                            .fixed_pos(pointer_pos + egui::vec2(16.0, 16.0))
                            .order(egui::Order::Tooltip)
                            .show(ui.ctx(), |ui| {
                                ui.label(format!("Moving {} item(s)", count));
                            });
                    }
                }

                // D&D: Drop Logic (Target)
                if let Some(source_path) = response.dnd_release_payload::<PathBuf>() {
                    self.handle_drop(source_path.as_ref(), &path, ui.ctx());
                    ui.ctx().request_repaint();
                }

                // Visual feedback for drop target
                if response.dnd_hover_payload::<PathBuf>().is_some() {
                    ui.painter().rect_stroke(
                        response.rect,
                        2.0,
                        egui::Stroke::new(2.0, Color32::LIGHT_GRAY),
                    );
                }

                // Selection Logic (Click on Label)
                if response.clicked() {
                    self.handle_click(&path, ui);
                }

                response.context_menu(|ui| {
                    self.context_menu_items(ui, &path, control, name.clone());
                });
            });

            // Sync expanded state using header_response
            if header_response.is_open() {
                self.expanded_nodes.insert(path.clone());
            } else {
                self.expanded_nodes.remove(&path);
            }

            header_response.body(|ui| {
                if let Ok(entries) = std::fs::read_dir(&path) {
                    let mut paths: Vec<_> = entries.flatten().map(|e| e.path()).collect();
                    paths.sort_by(|a, b| {
                        let a_is_dir = a.is_dir();
                        let b_is_dir = b.is_dir();
                        if a_is_dir != b_is_dir {
                            b_is_dir.cmp(&a_is_dir)
                        } else {
                            a.cmp(b)
                        }
                    });

                    for child_path in paths {
                        self.render_tree(ui, child_path, control);
                    }
                }
            });

        } else {
            // File display
            ui.horizontal(|ui| {
                ui.add_space(16.0); // Indentation
                
                let mut text = RichText::new(format!("üìÑ {}", name));
                if is_selected {
                    text = text.color(ui.visuals().selection.stroke.color);
                    text = text.background_color(ui.visuals().selection.bg_fill.gamma_multiply(0.3));
                }

                // Add sense: click_and_drag
                let response = ui.add(egui::SelectableLabel::new(is_selected, text)).interact(egui::Sense::drag());
                
                // D&D: Drag Source
                if response.dragged() {
                    response.dnd_set_drag_payload(path.clone());
                    
                    ui.ctx().set_cursor_icon(egui::CursorIcon::Grabbing);
                     if let Some(pointer_pos) = ui.ctx().pointer_interact_pos() {
                        let count = if is_selected && self.selected_items.len() > 1 {
                            self.selected_items.len()
                        } else {
                            1
                        };
                        egui::Area::new(id.with("dnd_tooltip"))
                            .fixed_pos(pointer_pos + egui::vec2(16.0, 16.0))
                            .order(egui::Order::Tooltip)
                            .show(ui.ctx(), |ui| {
                                ui.label(format!("Moving {} item(s)", count));
                            });
                    }
                }

                if response.clicked() {
                    self.handle_click(&path, ui);
                }
                
                if response.double_clicked() {
                    control.push(AppCommand::OpenFile(path.clone()));
                }

                response.context_menu(|ui| {
                    self.context_menu_items(ui, &path, control, name.clone());
                });
            });
        }
    }

    fn handle_click(&mut self, path: &PathBuf, ui: &Ui) {
        if ui.input(|i| i.modifiers.ctrl) {
            if self.selected_items.contains(path) {
                self.selected_items.remove(path);
            } else {
                self.selected_items.insert(path.clone());
            }
        } else {
            let was_selected = self.selected_items.contains(path) && self.selected_items.len() == 1;
            self.selected_items.clear();
            if !was_selected {
                self.selected_items.insert(path.clone());
            }
        }
    }

    fn handle_drop(&mut self, primary_source: &Path, target_dir: &Path, ctx: &egui::Context) {
        // Collect what to move
        let mut sources = Vec::new();
        if self.selected_items.contains(primary_source) {
            sources.extend(self.selected_items.iter().cloned());
        } else {
            sources.push(primary_source.to_path_buf());
        }

        // Filter valid moves
        let target_dir = target_dir.to_path_buf();
        let final_sources: Vec<PathBuf> = sources.into_iter()
            .filter(|p| {
                // Cannot move into itself or its own subfolder
                // Also cannot move if parent is already target
                if let Some(parent) = p.parent() {
                    if parent == target_dir { return false; }
                }
                if target_dir.starts_with(p) { return false; }
                true
            })
            .collect();

        if final_sources.is_empty() { return; }

        let pending = self.pending_commands.clone();
        let ctx_clone = ctx.clone();

        // Spawn background thread
        std::thread::spawn(move || {
            let mut success_count = 0;
            let mut errors = Vec::new();

            for src in final_sources {
                let file_name = match src.file_name() {
                    Some(n) => n,
                    None => continue,
                };
                let dest = target_dir.join(file_name);
                
                if dest.exists() {
                    errors.push(format!("{} exists", file_name.to_string_lossy()));
                    continue;
                }

                match std::fs::rename(&src, &dest) {
                    Ok(_) => success_count += 1,
                    Err(e) => errors.push(format!("{}: {}", file_name.to_string_lossy(), e)),
                }
            }

            let mut cmds = pending.lock().unwrap();
            if success_count > 0 {
                cmds.push(AppCommand::Notify {
                    message: format!("Moved {} items", success_count),
                    level: NotificationLevel::Success,
                });
            }
            if !errors.is_empty() {
                cmds.push(AppCommand::Notify {
                    message: format!("Errors: {}", errors.join(", ")),
                    level: NotificationLevel::Error,
                });
            }
            
            ctx_clone.request_repaint();
        });
    }

    fn context_menu_items(&mut self, ui: &mut Ui, path: &PathBuf, control: &mut Vec<AppCommand>, name: String) {
        if ui.button("Open").clicked() {
            if path.is_file() {
                control.push(AppCommand::OpenFile(path.clone()));
            }
            ui.close_menu();
        }
        if path.is_dir() {
            if ui.button("New File").clicked() {
                self.new_item_parent = Some((path.clone(), false));
                self.input_text = "new_file.txt".to_string();
                ui.close_menu();
            }
            if ui.button("New Folder").clicked() {
                self.new_item_parent = Some((path.clone(), true));
                self.input_text = "new_folder".to_string();
                ui.close_menu();
            }
            ui.separator();
        }
        
        if ui.button("Rename").clicked() {
            self.rename_path = Some(path.clone());
            self.input_text = name.clone();
            ui.close_menu();
        }
        if ui.button("Reveal in Explorer").clicked() {
            control.push(AppCommand::RevealInShell(path.clone()));
            ui.close_menu();
        }
        if ui.button("Copy Path").clicked() {
            control.push(AppCommand::CopyToClipboard(path.to_string_lossy().to_string()));
            ui.close_menu();
        }
        ui.separator();
        if ui.button("Delete").clicked() {
            // Support deleting multiple if selected
            let targets = if self.selected_items.contains(path) {
                self.selected_items.iter().cloned().collect::<Vec<_>>()
            } else {
                vec![path.clone()]
            };

            let mut success = 0;
            for p in targets {
                let res = if p.is_dir() { std::fs::remove_dir_all(&p) } else { std::fs::remove_file(&p) };
                if res.is_ok() { 
                    success += 1; 
                    self.expanded_nodes.remove(&p);
                    self.selected_items.remove(&p);
                }
            }
            
            if success > 0 {
                control.push(AppCommand::Notify { 
                    message: format!("Deleted {} items", success), 
                    level: NotificationLevel::Success 
                });
            }
            ui.close_menu();
        }
    }
}

impl TabInstance for FileExplorerTab {
    fn title(&self) -> WidgetText {
        if let Some(path) = &self.root_path {
            format!("üìÇ {}", path.file_name().map(|n| n.to_string_lossy()).unwrap_or_default()).into()
        } else {
            "üìÅ Explorer".into()
        }
    }

    fn ui(&mut self, ui: &mut Ui, control: &mut Vec<AppCommand>) {
        // Poll background commands
        self.process_pending_commands(control);

        ui.vertical(|ui| {
            // Toolbar
            ui.horizontal(|ui| {
                if ui.button("Open Folder...").clicked() {
                    if let Some(path) = rfd::FileDialog::new().pick_folder() {
                        self.root_path = Some(path);
                        self.selected_items.clear();
                    }
                }
                if self.root_path.is_some() {
                    if ui.button("Refresh").clicked() {
                        self.expanded_nodes.retain(|p| p.exists());
                    }
                    if ui.button("Close").clicked() {
                        self.root_path = None;
                        self.expanded_nodes.clear();
                        self.selected_items.clear();
                    }
                }
            });

            ui.separator();

            // Content
            if let Some(root) = self.root_path.clone() {
                egui::ScrollArea::vertical()
                    .auto_shrink([false, false])
                    .show(ui, |ui| {
                        // Create a large empty area that catches clicks to clear selection
                        let rect = ui.available_rect_before_wrap();
                        let response = ui.interact(rect, Id::new("explorer_empty_area"), egui::Sense::click());
                        if response.clicked() {
                            self.selected_items.clear();
                        }

                        self.render_tree(ui, root, control);
                    });
            } else {
                ui.centered_and_justified(|ui| {
                    ui.label("No directory selected.\nClick the button above to start exploring.");
                });
            }
        });

        // Dialogs (Rename / New Item)
        if let Some(path) = self.rename_path.clone() {
            let mut open = true;
            egui::Window::new("Rename")
                .open(&mut open)
                .collapsible(false)
                .resizable(false)
                .show(ui.ctx(), |ui| {
                    ui.label(format!("Old name: {}", path.file_name().unwrap_or_default().to_string_lossy()));
                    ui.text_edit_singleline(&mut self.input_text);
                    ui.horizontal(|ui| {
                        if ui.button("Rename").clicked() {
                            let new_path = path.parent().unwrap().join(&self.input_text);
                            match std::fs::rename(&path, new_path) {
                                Ok(_) => {
                                    self.rename_path = None;
                                    control.push(AppCommand::Notify { 
                                        message: "Renamed successfully".into(), 
                                        level: NotificationLevel::Success 
                                    });
                                }
                                Err(e) => {
                                    control.push(AppCommand::Notify { 
                                        message: format!("Rename failed: {}", e), 
                                        level: NotificationLevel::Error 
                                    });
                                }
                            }
                        }
                        if ui.button("Cancel").clicked() {
                            self.rename_path = None;
                        }
                    });
                });
            if !open { self.rename_path = None; }
        }

        if let Some((parent, is_dir)) = self.new_item_parent.clone() {
            let mut open = true;
            let title = if is_dir { "New Folder" } else { "New File" };
            egui::Window::new(title)
                .open(&mut open)
                .collapsible(false)
                .resizable(false)
                .show(ui.ctx(), |ui| {
                    ui.label(format!("Parent: {}", parent.to_string_lossy()));
                    ui.text_edit_singleline(&mut self.input_text);
                    ui.horizontal(|ui| {
                        if ui.button("Create").clicked() {
                            let new_path = parent.join(&self.input_text);
                            let res = if is_dir {
                                std::fs::create_dir_all(&new_path)
                            } else {
                                std::fs::File::create(&new_path).map(|_| ())
                            };

                            match res {
                                Ok(_) => {
                                    self.new_item_parent = None;
                                    self.expanded_nodes.insert(parent);
                                    control.push(AppCommand::Notify { 
                                        message: format!("Created {}", if is_dir { "folder" } else { "file" }), 
                                        level: NotificationLevel::Success 
                                    });
                                }
                                Err(e) => {
                                    control.push(AppCommand::Notify { 
                                        message: format!("Creation failed: {}", e), 
                                        level: NotificationLevel::Error 
                                    });
                                }
                            }
                        }
                        if ui.button("Cancel").clicked() {
                            self.new_item_parent = None;
                        }
                    });
                });
            if !open { self.new_item_parent = None; }
        }
    }

    fn box_clone(&self) -> Box<dyn TabInstance> {
        Box::new(self.clone())
    }
}

// ----------------------------------------------------------------------------
// Plugin Implementation
// ----------------------------------------------------------------------------

pub struct FileManagerPlugin;

impl Plugin for FileManagerPlugin {
    fn name(&self) -> &str {
        crate::plugins::PLUGIN_NAME_FILE_MANAGER
    }

    fn on_tab_menu(&mut self, ui: &mut Ui, control: &mut Vec<AppCommand>) {
        if ui.button("File Explorer").clicked() {
            control.push(AppCommand::OpenTab(Tab::new(Box::new(FileExplorerTab::new()))));
            ui.close_menu();
        }
    }
}

pub fn create() -> FileManagerPlugin {
    FileManagerPlugin
}