use std::fs;
use std::path::Path;

fn main() {
    let plugins_dir = "src/plugins";
    let dest_path = Path::new("src/plugins/generated.rs");

    let mut plugin_mods = String::new();
    let mut plugin_creations = String::new();
    let mut plugin_constants = String::new();

    if let Ok(entries) = fs::read_dir(plugins_dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                let folder_name = path.file_name().unwrap().to_str().unwrap();
                if folder_name != "core" && folder_name != "generated" {
                    // 1. 读取 plugin.toml 提取真实名称
                    let toml_path = path.join("plugin.toml");
                    let plugin_id = if toml_path.exists() {
                        let content = fs::read_to_string(&toml_path).unwrap();
                        let parsed: toml::Value = toml::from_str(&content).unwrap();
                        parsed["plugin"]["name"].as_str().unwrap().to_string()
                    } else {
                        folder_name.to_string()
                    };

                    let upper_name = folder_name.to_uppercase().replace("-", "_");
                    let const_name = format!("PLUGIN_NAME_{}", upper_name);

                    // 2. 生成模块定义
                    plugin_mods.push_str("#[cfg(feature = \"plugin_");
                    plugin_mods.push_str(folder_name);
                    plugin_mods.push_str("\")]\n");
                    plugin_mods.push_str("pub mod ");
                    plugin_mods.push_str(folder_name);
                    plugin_mods.push_str(";\n\n");

                    // 3. 生成常量
                    plugin_constants.push_str("#[cfg(feature = \"plugin_");
                    plugin_constants.push_str(folder_name);
                    plugin_constants.push_str("\")]\n");
                    plugin_constants.push_str("pub const ");
                    plugin_constants.push_str(&const_name);
                    plugin_constants.push_str(": &str = \"");
                    plugin_constants.push_str(&plugin_id);
                    plugin_constants.push_str("\";\n");

                    // 4. 生成实例化逻辑与校验
                    plugin_creations.push_str("        #[cfg(feature = \"plugin_");
                    plugin_creations.push_str(folder_name);
                    plugin_creations.push_str("\")]\n");
                    plugin_creations.push_str("        {\n");
                    plugin_creations.push_str("            let p = Box::new(");
                    plugin_creations.push_str(folder_name);
                    plugin_creations.push_str("::create());\n");
                    plugin_creations.push_str("            assert_eq!(p.name(), ");
                    plugin_creations.push_str(&const_name);
                    plugin_creations.push_str(", \"Plugin name mismatch for ");
                    plugin_creations.push_str(folder_name);
                    plugin_creations.push_str("\");\n");
                    plugin_creations.push_str("            plugins.push(p);\n");
                    plugin_creations.push_str("        }\n");
                }
            }
        }
    }

    let mut content = String::new();
    content.push_str("// Generated by build.rs. DO NOT EDIT.\n\n");
    content.push_str(&plugin_mods);
    content.push_str("\n// Plugin Name Constants\n");
    content.push_str(&plugin_constants);
    content.push_str("\npub fn get_extra_plugins() -> Vec<Box<dyn crate::Plugin>> {\n");
    content.push_str("    let mut plugins: Vec<Box<dyn crate::Plugin>> = Vec::new();\n");
    content.push_str(&plugin_creations);
    content.push_str("    plugins\n");
    content.push_str("}\n");

    fs::write(dest_path, content).unwrap();
    println!("cargo:rerun-if-changed={}", plugins_dir);
}