# Verbium Plugin Development Guide

This guide will help you write Verbium plugins. Plugins are first-class citizens in Verbium, capable of controlling almost everything from the menu bar to the editor panels.

## 1. Plugin Structure

Create a new folder under `src/plugins/` (e.g., `my_tool`) and include the following files:

### 1.1 `mod.rs` (Logic Implementation)
Must contain a struct that implements the `Plugin` trait and an exported `create()` function.

**Key Specification**:
- The `name()` method **must not** hard-code strings. It must reference the `crate::plugins::PLUGIN_NAME_...` constant (automatically generated by `build.rs`).

```rust
use egui::Ui;
use crate::{Plugin, AppCommand};

pub struct MyToolPlugin;

impl Plugin for MyToolPlugin {
    // Reference the automatically generated constant to keep in sync with plugin.toml
    fn name(&self) -> &str { crate::plugins::PLUGIN_NAME_MY_TOOL }
    
    // Implement hook methods...
}

pub fn create() -> MyToolPlugin {
    MyToolPlugin
}
```

### 1.2 `plugin.toml` (Metadata & Dependencies)

Mandatory file. Used to define the plugin ID, display name, author information, and external crate dependencies.

```toml
[plugin]
name = "my_tool"              # Internal ID (must match the module name)
display_name = "My Tool"      # Name displayed in the Launcher
version = "0.1.0"
author = "Your Name"
description = "A sample tool"
dependencies = ["core"]       # IDs of other plugins depended upon

[external_dependencies]
serde = { version = "1.0", features = ["derive"] }
rand = "0.8"
```

---

## 2. API Reference (Trait Hooks)

### UI Injection Hooks
| Method | Description |
| :--- | :--- |
| `on_file_menu` | Inject content into the top "File" menu. |
| `on_tab_menu` | Inject content into the top "Tab" menu. |
| `on_menu_bar` | Add custom top-level menus (e.g., "Tools", "Help") to the menu bar. |
| `on_global_ui` | Draw global overlays (e.g., modals). Note: For toast notifications, use the `Notify` command. |
| `on_settings_ui` | Draw plugin configuration options within the global settings window. |

---

## 3. Development Specifications & Best Practices

### 3.1 Async I/O
Strictly prohibit synchronous blocking operations in `ui()` or `try_open_file()`.
- **Pattern**: Start a thread to handle I/O and keep the Tab in a `Loading` state.
- **Feedback**: Use `control.push(AppCommand::Notify { ... })` to inform the user of operation results.

### 3.2 OS Abstraction
Do not directly use `std::process::Command` or platform-specific shell commands.
- **File Management**: Use `AppCommand::RevealInShell(path)`.
- **Clipboard**: Use `AppCommand::CopyToClipboard(text)`.

### 3.3 Notification System
Avoid writing your own modal logic for simple feedback. Use the global notification system:
```rust
control.push(AppCommand::Notify {
    message: "File saved successfully".into(),
    level: crate::NotificationLevel::Success,
});
```
---
